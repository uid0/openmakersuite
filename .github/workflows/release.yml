name: üöÄ Automated Release & Deploy

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]

# Allow manual triggering for testing
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  packages: write
  id-token: write  # Required for signing

jobs:
  check-prerequisites:
    name: üîç Check Prerequisites
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      last_release: ${{ steps.check.outputs.last_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if release needed
        id: check
        run: |
          # Get the last release
          LAST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName // "v0.0.0"')
          echo "last_release=$LAST_RELEASE" >> $GITHUB_OUTPUT
          
          # Check if there are new commits since last release
          if [ "$LAST_RELEASE" = "v0.0.0" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "üÜï No previous releases found, will create first release"
          else
            NEW_COMMITS=$(git rev-list ${LAST_RELEASE}..HEAD --count)
            if [ $NEW_COMMITS -gt 0 ]; then
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "üìà Found $NEW_COMMITS new commits since $LAST_RELEASE"
            else
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "‚úÖ No new commits since $LAST_RELEASE"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-version:
    name: üìã Generate Version
    runs-on: ubuntu-latest
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.should_release == 'true'
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      new_tag: ${{ steps.version.outputs.new_tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate new version
        id: version
        run: |
          LAST_RELEASE="${{ needs.check-prerequisites.outputs.last_release }}"
          
          # Parse current version (remove 'v' prefix)
          if [ "$LAST_RELEASE" = "v0.0.0" ]; then
            CURRENT_VERSION="0.0.0"
          else
            CURRENT_VERSION=${LAST_RELEASE#v}
          fi
          
          echo "Current version: $CURRENT_VERSION"
          
          # Split version into parts
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Determine release type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Auto-detect based on commit messages
            COMMITS=$(git log ${LAST_RELEASE}..HEAD --pretty=format:"%s" || git log --pretty=format:"%s")
            if echo "$COMMITS" | grep -i "breaking\|major" > /dev/null; then
              RELEASE_TYPE="major"
            elif echo "$COMMITS" | grep -i "feat\|feature\|minor" > /dev/null; then
              RELEASE_TYPE="minor"  
            else
              RELEASE_TYPE="patch"
            fi
          fi
          
          echo "Release type: $RELEASE_TYPE"
          
          # Increment version
          case $RELEASE_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è New version will be: $NEW_TAG"

      - name: Generate changelog
        id: changelog
        run: |
          LAST_RELEASE="${{ needs.check-prerequisites.outputs.last_release }}"
          NEW_TAG="${{ steps.version.outputs.new_tag }}"
          
          echo "## üöÄ Release $NEW_TAG" > changelog.md
          echo "" >> changelog.md
          echo "### üìù Changes" >> changelog.md
          
          if [ "$LAST_RELEASE" = "v0.0.0" ]; then
            echo "- üéâ Initial release" >> changelog.md
            echo "- ‚ú® Full makerspace inventory management system" >> changelog.md
          else
            # Generate changelog from commits
            git log ${LAST_RELEASE}..HEAD --pretty=format:"- %s" --no-merges >> changelog.md || echo "- üéâ Initial release" >> changelog.md
          fi
          
          echo "" >> changelog.md
          echo "### üîß Technical Details" >> changelog.md
          echo "- **Backend Coverage**: $(grep -o 'Total coverage: [0-9.]*%' backend/htmlcov/index.html 2>/dev/null || echo 'N/A')" >> changelog.md
          echo "- **Frontend Coverage**: Available in CI reports" >> changelog.md
          echo "- **Security**: All Bandit and Safety checks passed" >> changelog.md
          echo "- **Tests**: All backend and frontend tests passing" >> changelog.md
          
          # Read changelog content for output
          CHANGELOG_CONTENT=$(cat changelog.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT  
          echo "EOF" >> $GITHUB_OUTPUT

  build-artifacts:
    name: üèóÔ∏è Build Release Artifacts
    runs-on: ubuntu-latest
    needs: [check-prerequisites, generate-version]
    if: needs.check-prerequisites.outputs.should_release == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker images
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          REPO_NAME="${{ github.repository }}"
          REPO_LOWER=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')
          
          # Build backend image
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag ghcr.io/$REPO_LOWER/backend:$NEW_TAG \
            --tag ghcr.io/$REPO_LOWER/backend:latest \
            --push \
            --file backend/Dockerfile \
            backend/
          
          # Build frontend image  
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag ghcr.io/$REPO_LOWER/frontend:$NEW_TAG \
            --tag ghcr.io/$REPO_LOWER/frontend:latest \
            --push \
            --file frontend/Dockerfile \
            frontend/

      - name: Create release bundle
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          
          # Create release directory
          mkdir -p release-bundle
          
          # Copy deployment files
          cp docker-compose.yml release-bundle/
          cp -r .env.example release-bundle/
          
          # Create deployment script
          cat > release-bundle/deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "üöÄ Deploying OpenMakerSuite ${{ needs.generate-version.outputs.new_tag }}"
          
          # Check for required files
          if [ ! -f .env ]; then
            echo "‚ö†Ô∏è  Creating .env from example..."
            cp .env.example .env
            echo "üìù Please edit .env with your configuration"
          fi
          
          # Pull and start services
          docker compose pull
          docker compose up -d
          
          echo "‚úÖ Deployment complete!"
          echo "üåê Frontend: http://localhost:3000"  
          echo "üîß Backend: http://localhost:8000"
          echo "üë®‚Äçüíº Admin: http://localhost:8000/admin"
          EOF
          
          chmod +x release-bundle/deploy.sh
          
          # Create documentation
          cat > release-bundle/README.md << EOF
          # OpenMakerSuite Release ${{ needs.generate-version.outputs.new_tag }}
          
          This release bundle contains everything needed to deploy OpenMakerSuite.
          
          ## Quick Start
          
          1. Extract this bundle
          2. Copy \`.env.example\` to \`.env\` and configure
          3. Run: \`./deploy.sh\`
          
          ## What's Included
          
          - \`docker-compose.yml\` - Container orchestration
          - \`deploy.sh\` - Automated deployment script  
          - \`.env.example\` - Environment configuration template
          
          ## Container Images
          
          - Backend: \`ghcr.io/${{ github.repository }}/backend:${{ needs.generate-version.outputs.new_tag }}\`
          - Frontend: \`ghcr.io/${{ github.repository }}/frontend:${{ needs.generate-version.outputs.new_tag }}\`
          
          EOF
          
          # Create tarball
          tar -czf openmakersuite-$NEW_TAG.tar.gz -C release-bundle .
          
          # Generate checksums
          sha256sum openmakersuite-$NEW_TAG.tar.gz > openmakersuite-$NEW_TAG.tar.gz.sha256
          
          echo "üì¶ Release bundle created: openmakersuite-$NEW_TAG.tar.gz"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            openmakersuite-*.tar.gz
            openmakersuite-*.tar.gz.sha256

  sign-and-release:
    name: üîê Sign & Create Release
    runs-on: ubuntu-latest
    needs: [check-prerequisites, generate-version, build-artifacts]
    if: needs.check-prerequisites.outputs.should_release == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts

      - name: Install cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.2'

      - name: Sign release artifacts
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          
          # Sign the release bundle with keyless signing (Sigstore)
          cosign sign-blob \
            --output-signature openmakersuite-$NEW_TAG.tar.gz.sig \
            --output-certificate openmakersuite-$NEW_TAG.tar.gz.pem \
            openmakersuite-$NEW_TAG.tar.gz
          
          echo "üîê Artifacts signed successfully"
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Create GitHub Release
        id: create_release
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          
          # Create the release
          gh release create "$NEW_TAG" \
            --title "üöÄ Release $NEW_TAG" \
            --notes "${{ needs.generate-version.outputs.changelog }}" \
            --latest \
            openmakersuite-$NEW_TAG.tar.gz \
            openmakersuite-$NEW_TAG.tar.gz.sha256 \
            openmakersuite-$NEW_TAG.tar.gz.sig \
            openmakersuite-$NEW_TAG.tar.gz.pem
          
          echo "‚úÖ GitHub release created: $NEW_TAG"
          echo "release_url=$(gh release view $NEW_TAG --json url --jq .url)" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  sentry-integration:
    name: üìä Sentry Release Integration  
    runs-on: ubuntu-latest
    needs: [check-prerequisites, generate-version, sign-and-release]
    if: needs.check-prerequisites.outputs.should_release == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Sentry release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          version: ${{ needs.generate-version.outputs.new_tag }}
          environment: production
          ignore_missing: true
          ignore_empty: true

      - name: Associate commits with Sentry release
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          LAST_RELEASE="${{ needs.check-prerequisites.outputs.last_release }}"
          
          # Install Sentry CLI
          curl -sL https://sentry.io/get-cli/ | bash
          
          # Set commits for this release
          if [ "$LAST_RELEASE" != "v0.0.0" ]; then
            sentry-cli releases set-commits "$NEW_TAG" --commit "${{ github.repository }}@${LAST_RELEASE}..HEAD"
          else
            sentry-cli releases set-commits "$NEW_TAG" --auto
          fi
          
          # Finalize the release in Sentry
          sentry-cli releases finalize "$NEW_TAG"
          
          echo "‚úÖ Sentry release $NEW_TAG created and finalized"
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}

  notify-success:
    name: üéâ Notification
    runs-on: ubuntu-latest
    needs: [check-prerequisites, generate-version, sign-and-release, sentry-integration]
    if: needs.check-prerequisites.outputs.should_release == 'true'
    steps:
      - name: Send success notification
        run: |
          NEW_TAG="${{ needs.generate-version.outputs.new_tag }}"
          RELEASE_URL="${{ needs.sign-and-release.outputs.release_url }}"
          
          echo "üéâ SUCCESS: Release $NEW_TAG has been created and published!"
          echo "üì¶ Release URL: $RELEASE_URL"
          echo "üîê Cryptographically signed with Sigstore"
          echo "üìä Associated with Sentry for monitoring"
          
          # If Slack webhook is configured, send notification
          if [ ! -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"üöÄ *OpenMakerSuite $NEW_TAG Released!*\nüì¶ <$RELEASE_URL|Download Release>\nüîê Cryptographically signed\nüìä Sentry monitoring enabled\"}" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
          fi
